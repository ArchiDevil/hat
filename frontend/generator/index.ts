import commandLineArgs from 'command-line-args'
import {existsSync, mkdirSync, writeFileSync, rmSync} from 'fs'
import {join} from 'path'

type RefDesc = {
  $ref: string
}

type AnyOfDesc = {
  anyOf: [
    {
      type: 'string' | 'integer' // | 'boolean' // check if boolean is possible
    }
  ]
}

type TrivialDesc = {
  type: 'string' | 'integer' // | 'boolean' // check if boolean is possible
  title?: string
  format?: string
}

type ArrayDesc = {
  type: 'array'
  items: RefDesc | AnyOfDesc
  title?: string
}

// TODO: check if AnyOfDesc is possible here without an array
type PropDescription = TrivialDesc | ArrayDesc | RefDesc

type HttpMethod = 'get' | 'post' | 'put' | 'delete'

interface ParamDesc {
  name: string
  in: 'query' | 'path' | 'header'
  required: boolean
  schema: PropDescription
}

interface MethodDesc {
  tags: string[]
  summary: string
  operationId: string
  parameters?: ParamDesc[]
  requestBody?: any // TODO: describe
  responses: {
    [status: string]: {
      description: string
      content?: {
        [contentType: string]: {
          schema: PropDescription
        }
      }
    }
  }
}

interface ApiDescription {
  openapi: string
  info: {
    title: string
    version: string
  }
  paths: {
    [path: string]: {
      [method in HttpMethod]: MethodDesc
    }
  }
  components: {
    schemas: {
      [name: string]: {
        type: string
        title: string
        required?: string[]
        properties: {
          [name: string]: PropDescription
        }
      }
    }
  }
}

const autogenPrologue =
  '// This file is autogenerated, do not edit directly.\n\n'

function getReferencedType(ref: string): string {
  // TODO: it should be done better, not by just splitting the string
  return ref.split('/').pop()
}

function getImports(types: Iterable<string>, schemasPath: string): string {
  const imports: string[] = []
  for (const type of types) {
    imports.push(`import {${type}} from '${schemasPath}${type}'`)
  }
  return `${imports.join('\n')}` + (imports.length > 0 ? '\n\n' : '')
}

function tsType(prop: PropDescription): string {
  if ('$ref' in prop) {
    return getReferencedType(prop['$ref'])
  }

  switch (prop.type) {
    case 'string': {
      if ('format' in prop && prop['format'] == 'binary') {
        return 'Blob'
      }

      return 'string'
    }
    case 'integer':
      return 'number'
    // TODO: check if it possible to have boolean
    // case 'boolean':
    //   return 'boolean'
    case 'array': {
      if (prop.items) {
        // TODO: call tsType recursively?
        if ('$ref' in prop.items) {
          const ref = prop.items['$ref']
          return `${getReferencedType(ref)}[]`
        } else if ('anyOf' in prop.items) {
          const elems = prop.items['anyOf']
          return `(${elems
            .map((val) => tsType({type: val.type}))
            .join(' | ')})[]`
        } else {
          console.warn('Unsupported array items:', prop.items)
          return 'any[]'
        }
      } else {
        console.warn('Unsupported array type:', prop.items)
        return 'any[]'
      }
    }
    default:
      console.warn('Unsupported type:', (prop as TrivialDesc | ArrayDesc).type)
      return 'any'
  }
}

function genSchemas(
  output: string,
  schemas: ApiDescription['components']['schemas']
): void {
  const genProps = (
    props: {[name: string]: PropDescription},
    requiredProps: string[]
  ) => {
    let content = ''
    for (const propName in props) {
      const prop = props[propName]
      const required = requiredProps.find((val) => propName == val) ? '' : '?'
      content += `  ${propName}${required}: ${tsType(prop)}\n`
    }
    return content
  }

  const getUsedTypes = (properties: {
    [name: string]: PropDescription
  }): string[] => {
    const imports = new Set<string>()
    for (const propName in properties) {
      const prop = properties[propName]
      if ('$ref' in prop) {
        const type = getReferencedType(prop['$ref'])
        imports.add(type)
      } else {
        // TODO: make it smarter
        if (prop.type === 'array' && prop.items && '$ref' in prop.items) {
          const type = getReferencedType(prop.items['$ref'])
          imports.add(type)
        }
      }
    }
    return Array.from(imports)
  }

  const genSchema = (schema: string) => {
    const types = getUsedTypes(schemas[schema].properties)
    const imports = `${getImports(types, './')}`
    const props = genProps(
      schemas[schema].properties,
      schemas[schema].required || []
    )
    return `${autogenPrologue}${imports}export interface ${schema} {\n${props}}\n`
  }

  if (existsSync(output)) {
    rmSync(output, {recursive: true})
  }
  mkdirSync(output, {recursive: true})

  for (const schema in schemas) {
    const fileContent = `${genSchema(schema)}`
    const fileName = `${output}/${schema}.ts`
    writeFileSync(fileName, fileContent)
  }
}

function genServices(output: string, paths: ApiDescription['paths']): void {
  interface ServiceMethod {
    path: string
    httpMethod: HttpMethod
    description: MethodDesc
  }

  const convertServiceName = (name: string) => {
    // remove all spaces and special characters
    const normalized = name.replace(/[^a-zA-Z0-9]/g, '')

    // convert to camel case
    return `${normalized.charAt(0).toLowerCase()}${normalized.slice(1)}`
  }

  const serviceNameFromTag = (tag: string) => {
    const lowered = tag.toLowerCase()
    return `${lowered.charAt(0).toUpperCase()}${lowered.slice(1)}Service`
  }

  const responseType = (
    response: ApiDescription['paths'][string][HttpMethod]['responses'][string]
  ) => {
    if (!response.content) {
      return 'undefined'
    }
    if (!('application/json' in response.content)) {
      console.warn('Unsupported response content:', response.content)
      return 'any'
    }

    const schema = response.content['application/json'].schema
    return tsType(schema)
  }

  const genService = (methods: ServiceMethod[]) => {
    let content = ''
    const types = new Set<string>()
    for (const method of methods) {
      // TODO: it is better to search for suitable response, not for a default
      const response = responseType(method.description.responses['200'])

      // TODO: this should be done in a more smarter way
      if (
        response != 'any' &&
        !response.endsWith('[]') &&
        response != 'null' &&
        response != 'undefined'
      ) {
        types.add(response)
      }
      const paramSignature = (param: ParamDesc) =>
        `${param.name}${!param.required ? '?' : ''}: ${tsType(param.schema)}`

      const requestParams = (method.description.parameters ?? [])
        .map((param) => `${paramSignature(param)}`)
        .join(', ')

      // replace all OpenAPI path parameters with JS template literals
      const interpolatedPath = method.path.replace(/\{(.*)?\}/g, '${$1}')

      const funcSignature =
        response != 'undefined'
          ? `async (${requestParams}): Promise<${response}>`
          : `async (${requestParams}): Promise<void>`

      const mandeType = response != 'undefined' ? `<${response}>` : ''
      const methodName = convertServiceName(method.description.summary)

      content += `export const ${methodName} = ${funcSignature} => {\n`
      content += `  const api = mande(\`${interpolatedPath}\`)\n`
      content += `  return await api.${method.httpMethod}${mandeType}('')\n`
      content += `}\n`
    }

    let fileContent = `${autogenPrologue}`
    fileContent += `import {mande} from 'mande'\n\n`
    fileContent += `${getImports(types, '../schemas/')}`
    fileContent += `${content}`
    return fileContent
  }

  if (existsSync(output)) {
    rmSync(output, {recursive: true})
  }
  mkdirSync(output, {recursive: true})

  // group services by tags
  const servicesByTag = new Map<string, ServiceMethod[]>()
  for (const path in paths) {
    const methods = paths[path]
    for (const method in methods) {
      const methodDesc = methods[method as HttpMethod]
      const tags = methodDesc.tags
      for (const tag of tags) {
        if (!servicesByTag.has(tag)) {
          servicesByTag.set(tag, [])
        }
        servicesByTag.get(tag).push({
          path: path,
          httpMethod: method as HttpMethod,
          description: methodDesc,
        })
      }
    }
  }

  // generator actual code for every service
  for (const [tag, methods] of servicesByTag) {
    const fileContent = genService(methods)
    const fileName = `${output}/${serviceNameFromTag(tag)}.ts`
    writeFileSync(fileName, fileContent)
  }
}

function main() {
  const options = commandLineArgs([
    {name: 'input', alias: 'i', type: String},
    {name: 'output', alias: 'o', type: String},
  ])

  fetch(options.input)
    .then((response) => {
      response.json().then((data: ApiDescription) => {
        if (existsSync(options.output)) {
          rmSync(options.output, {recursive: true})
        }
        mkdirSync(options.output, {recursive: true})

        genSchemas(join(options.output, 'schemas'), data.components.schemas)
        genServices(join(options.output, 'services'), data.paths)
      })
    })
    .catch((error) => {
      console.error('Failure:', error)
    })
}

main()
