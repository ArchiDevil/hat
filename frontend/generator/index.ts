import commandLineArgs from 'command-line-args'
import {existsSync, mkdirSync, writeFileSync, rmSync} from 'fs'
import {join} from 'path'

import {
  ApiDescription,
  ArrayDesc,
  HttpMethod,
  MethodDesc,
  PropDescription,
  TrivialDesc,
} from './interfaces'

const autogenPrologue =
  '// This file is autogenerated, do not edit directly.\n\n'

function getReferencedType(ref: string): string {
  // TODO: it should be done better, not by just splitting the string
  return ref.split('/').pop() ?? ''
}

function getImports(types: Iterable<string>, schemasPath: string): string {
  const imports: string[] = []
  for (const type of types) {
    imports.push(`import {${type}} from '${schemasPath}${type}'`)
  }
  return `${imports.join('\n')}` + (imports.length > 0 ? '\n\n' : '')
}

function tsType(prop: PropDescription): string {
  if ('$ref' in prop) {
    return getReferencedType(prop['$ref'])
  }

  switch (prop.type) {
    case 'string': {
      if ('format' in prop && prop['format'] == 'binary') {
        return 'Blob'
      }

      return 'string'
    }
    case 'integer':
      return 'number'
    // TODO: check if it possible to have boolean
    // case 'boolean':
    //   return 'boolean'
    case 'array': {
      if (prop.items) {
        // TODO: call tsType recursively?
        if ('$ref' in prop.items) {
          const ref = prop.items['$ref']
          return `${getReferencedType(ref)}[]`
        } else if ('anyOf' in prop.items) {
          const elems = prop.items['anyOf']
          return `(${elems
            .map((val) => tsType({type: val.type}))
            .join(' | ')})[]`
        } else {
          console.warn('Unsupported array items:', prop.items)
          return 'any[]'
        }
      } else {
        console.warn('Unsupported array type:', prop.items)
        return 'any[]'
      }
    }
    default:
      console.warn('Unsupported type:', (prop as TrivialDesc | ArrayDesc).type)
      return 'any'
  }
}

function genDefaults(output: string, apiPrefix: string): void {
  let content = ''
  content += `${autogenPrologue}`
  content += `export const getApiBase = () => {\n`
  content += `  if (import.meta.env.DEV) {\n`
  content += `    return 'http://localhost:8000'\n`
  content += `  } else {\n`
  content += `    return '${apiPrefix}'\n`
  content += `  }\n`
  content += `}\n`

  const fileName = `${output}/defaults.ts`
  writeFileSync(fileName, content)
}

function genSchemas(
  output: string,
  schemas: ApiDescription['components']['schemas']
): void {
  const genProps = (
    props: {[name: string]: PropDescription},
    requiredProps: string[]
  ) => {
    let content = ''
    for (const propName in props) {
      const prop = props[propName]
      const required = requiredProps.find((val) => propName == val) ? '' : '?'
      content += `  ${propName}${required}: ${tsType(prop)}\n`
    }
    return content
  }

  const getUsedTypes = (properties: {
    [name: string]: PropDescription
  }): string[] => {
    const imports = new Set<string>()
    for (const propName in properties) {
      const prop = properties[propName]
      if ('$ref' in prop) {
        const type = getReferencedType(prop['$ref'])
        imports.add(type)
      } else {
        // TODO: make it smarter
        if (prop.type === 'array' && prop.items && '$ref' in prop.items) {
          const type = getReferencedType(prop.items['$ref'])
          imports.add(type)
        }
      }
    }
    return Array.from(imports)
  }

  const genSchema = (schema: string) => {
    const types = getUsedTypes(schemas[schema].properties)
    const imports = `${getImports(types, './')}`
    const props = genProps(
      schemas[schema].properties,
      schemas[schema].required || []
    )
    return `${autogenPrologue}${imports}export interface ${schema} {\n${props}}\n`
  }

  if (existsSync(output)) {
    rmSync(output, {recursive: true})
  }
  mkdirSync(output, {recursive: true})

  for (const schema in schemas) {
    const fileContent = `${genSchema(schema)}`
    const fileName = `${output}/${schema}.ts`
    writeFileSync(fileName, fileContent)
  }
}

function genServices(output: string, paths: ApiDescription['paths']): void {
  interface ServiceMethod {
    path: string
    httpMethod: HttpMethod
    description: MethodDesc
  }

  const convertServiceName = (name: string) => {
    // remove all spaces and special characters
    const normalized = name.replace(/[^a-zA-Z0-9]/g, '')

    // convert to camel case
    return `${normalized.charAt(0).toLowerCase()}${normalized.slice(1)}`
  }

  const convertServiceNameToLink = (name: string) => {
    // remove all spaces and special characters
    const normalized = name.replace(/[^a-zA-Z0-9]/g, '')

    // convert to camel case
    return `get${normalized}Link`
  }

  const serviceNameFromTag = (tag: string) => {
    const lowered = tag.toLowerCase()
    return `${lowered.charAt(0).toUpperCase()}${lowered.slice(1)}Service`
  }

  const responseType = (response: MethodDesc['responses'][string]) => {
    if (!response.content) {
      return 'undefined'
    }

    if (!('application/json' in response.content)) {
      console.warn('Unsupported response content:', response.content)
      return 'any'
    }

    const schema = response.content['application/json'].schema
    return tsType(schema)
  }

  const genService = (methods: ServiceMethod[]) => {
    let content = ''
    const types = new Set<string>()
    // TODO: Remove WA when mande 2.0.9+ is released
    let mandeWaActive = false
    for (const method of methods) {
      // TODO: it is better to search for suitable response, not for a default
      const responseData = method.description.responses['200']

      const paramSig = (
        name: string,
        required: boolean,
        schema: PropDescription
      ) => {
        const type = tsType(schema)
        return `${name}${required ? '' : '?'}: ${type}`
      }

      if (
        responseData.content &&
        'application/octet-stream' in responseData.content
      ) {
        const paramsList = (method.description.parameters ?? []).map(
          (param) => `${paramSig(param.name, param.required, param.schema)}`
        )

        // replace all OpenAPI path parameters with JS template literals
        const interpolatedPath = method.path.replace(/\{(.*)?\}/g, '${$1}')
        const requestParams = paramsList.join(', ')
        const methodName = convertServiceNameToLink(method.description.summary)
        const funcSignature = `(${requestParams}): string`

        content += `export const ${methodName} = ${funcSignature} => {\n`
        content += `  return getApiBase() + \`${interpolatedPath}\`\n`
        content += `}\n`
      } else {
        const respType = responseType(responseData)

        // TODO: this should be done in a smarter way
        if (
          respType != 'any' &&
          respType != 'null' &&
          respType != 'undefined' &&
          !respType.endsWith('[]')
        ) {
          types.add(respType)
        }

        const paramsList = (method.description.parameters ?? []).map(
          (param) => `${paramSig(param.name, param.required, param.schema)}`
        )

        if (method.description.requestBody) {
          // TODO: check it smarter, not hardcoded 'multipart/form-data'
          const schema =
            method.description.requestBody.content['multipart/form-data'].schema
          const type = tsType(schema)
          types.add(type)
          paramsList.push(`data: ${type}`)
        }

        const requestParams = paramsList.join(', ')

        // replace all OpenAPI path parameters with JS template literals
        const interpolatedPath = method.path.replace(/\{(.*)?\}/g, '${$1}')

        const retVal = respType != 'undefined' ? respType : 'void'
        const funcSignature = `async (${requestParams}): Promise<${retVal}>`

        const mandeType = respType != 'undefined' ? `<${respType}>` : ''
        const methodName = convertServiceName(method.description.summary)

        let functionBody = ''
        if (method.description.requestBody) {
          mandeWaActive = true
          // TODO: it should be done smarter, not just hardcoded 'file'
          const fileParamName = 'file'
          const fileParam = `data.${fileParamName}`

          functionBody += `  const formData = new FormData()\n`
          functionBody += `  formData.append('file', ${fileParam})\n`
          // TODO: Remove WA when mande 2.0.9+ is released
          functionBody += `  const defaultHeaders = defaults.headers\n`
          functionBody += `  try {\n`
          functionBody += `    const api = mande(getApiBase() + \`${interpolatedPath}\`)\n`
          functionBody += `    defaults.headers = {}\n`
          functionBody += `    return await api.${method.httpMethod}${mandeType}('', formData)\n`
          functionBody += `  } catch (error: any) {\n`
          functionBody += `    throw error\n`
          functionBody += `  } finally {\n`
          functionBody += `    defaults.headers = defaultHeaders\n`
          functionBody += `  }\n`
        } else {
          functionBody += `  const api = mande(getApiBase() + \`${interpolatedPath}\`)\n`
          functionBody += `  return await api.${method.httpMethod}${mandeType}('')\n`
        }

        content += `export const ${methodName} = ${funcSignature} => {\n`
        content += `${functionBody}`
        content += `}\n`
      }
    }

    let fileContent = `${autogenPrologue}`
    if (mandeWaActive) {
      fileContent += `import {defaults, mande} from 'mande'\n\n`
    } else {
      fileContent += `import {mande} from 'mande'\n\n`
    }
    fileContent += `import {getApiBase} from '../defaults'\n\n`
    fileContent += `${getImports(types, '../schemas/')}`
    fileContent += `${content}`
    return fileContent
  }

  if (existsSync(output)) {
    rmSync(output, {recursive: true})
  }
  mkdirSync(output, {recursive: true})

  // group services by tags
  const servicesByTag = new Map<string, ServiceMethod[]>()
  for (const path in paths) {
    const methods = paths[path]
    for (const method in methods) {
      const methodDesc = methods[method as HttpMethod]
      const tags = methodDesc.tags
      for (const tag of tags) {
        if (!servicesByTag.has(tag)) {
          servicesByTag.set(tag, [])
        }
        servicesByTag.get(tag)!.push({
          path: path,
          httpMethod: method as HttpMethod,
          description: methodDesc,
        })
      }
    }
  }

  // generator actual code for every service
  for (const [tag, methods] of servicesByTag) {
    const fileContent = genService(methods)
    const fileName = `${output}/${serviceNameFromTag(tag)}.ts`
    writeFileSync(fileName, fileContent)
  }
}

function main() {
  const options = commandLineArgs([
    {name: 'input', alias: 'i', type: String},
    {name: 'prefix', alias: 'p', type: String, defaultValue: ''},
    {name: 'output', alias: 'o', type: String},
  ])

  fetch(options.input)
    .then((response) => {
      response.json().then((data: ApiDescription) => {
        if (existsSync(options.output)) {
          rmSync(options.output, {recursive: true})
        }
        mkdirSync(options.output, {recursive: true})

        genDefaults(options.output, options.prefix)
        genSchemas(join(options.output, 'schemas'), data.components.schemas)
        genServices(join(options.output, 'services'), data.paths)
      })
    })
    .catch((error) => {
      console.error('Failure:', error)
    })
}

main()
