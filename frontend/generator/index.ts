import commandLineArgs from 'command-line-args'
import {existsSync, mkdirSync, writeFileSync, rmSync} from 'fs'
import {join} from 'path'

type ItemsDescription =
  | {
      $ref: string
    }
  | {
      anyOf: {
        type: 'string' | 'integer'
      }
    }

type PropDescription =
  | {
      type: 'string' | 'integer'
      title?: string
      format?: string
    }
  | {
      type: 'array'
      items: ItemsDescription
      title?: string
    }

interface ApiDescription {
  info: {
    title: string
    version: string
  }
  paths: Array<{
    [path: string]: {
      [method: string]: {
        summary: string
        operationId: string
        responses: {
          [status: string]: {
            description: string
          }
        }
      }
    }
  }>
  components: {
    schemas: {
      [name: string]: {
        type: string
        title: string
        required?: string[]
        properties: {
          [name: string]: PropDescription
        }
      }
    }
  }
}

function getReferencedType(ref: string) {
  // TODO: it should be done better, not by just splitting the string
  return ref.split('/').pop()
}

function getUsedTypes(
  properties: ApiDescription['components']['schemas'][string]['properties']
) {
  const imports = new Set<string>()
  for (const propName in properties) {
    const prop = properties[propName]
    if (prop.type === 'array' && prop.items && prop.items['$ref']) {
      const type = getReferencedType(prop.items['$ref'])
      imports.add(`import {${type}} from './${type}'`)
    }
  }
  return `${Array.from(imports).join('\n')}` + (imports.size > 0 ? '\n\n' : '')
}

function tsType(
  type: 'string' | 'integer' | 'boolean' | 'array',
  items?: ItemsDescription
) {
  switch (type) {
    case 'string':
      return 'string'
    case 'integer':
      return 'number'
    case 'boolean':
      return 'boolean'
    case 'array': {
      if (items && items['$ref']) {
        return `${getReferencedType(items['$ref'])}[]`
      } else {
        console.warn('Unsupported array type:', items)
        return 'any[]'
      }
    }
    default:
      console.warn('Unsupported type:', type)
      return 'any'
  }
}

function genSchemas(
  output: string,
  schemas: ApiDescription['components']['schemas']
) {
  const genProp = (
    propName: string,
    propType: 'string' | 'boolean' | 'array' | 'integer',
    required: boolean,
    items?: ItemsDescription
  ) => `  ${propName}${required ? '' : '?'}: ${tsType(propType, items)}`

  const genProps = (
    props: ApiDescription['components']['schemas'][string]['properties'],
    required: string[]
  ) => {
    let content = ''
    for (const propName in props) {
      const prop = props[propName]
      content += `${genProp(
        propName,
        prop.type,
        required.find((val) => propName == val) !== undefined,
        prop.type === 'array' ? prop.items : undefined
      )}\n`
    }
    return content
  }

  const genSchema = (schema: string) => {
    const prologue = '// This file is autogenerated, do not edit directly.\n\n'
    const imports = `${getUsedTypes(schemas[schema].properties)}`
    return `${prologue}${imports}export interface ${schema} {\n${genProps(
      schemas[schema].properties,
      schemas[schema].required || []
    )}}\n`
  }

  if (existsSync(output)) {
    rmSync(output, {recursive: true})
  }
  mkdirSync(output, {recursive: true})
  for (const schema in schemas) {
    const fileContent = `${genSchema(schema)}`
    const fileName = `${output}/${schema}.ts`
    writeFileSync(fileName, fileContent)
  }
}

function main() {
  const options = commandLineArgs([
    {name: 'input', alias: 'i', type: String},
    {name: 'output', alias: 'o', type: String},
  ])

  fetch(options.input)
    .then((response) => {
      response.json().then((data: ApiDescription) => {
        genSchemas(join(options.output, 'schemas'), data.components.schemas)
      })
    })
    .catch((error) => {
      console.error('Failure:', error)
    })
}

main()
