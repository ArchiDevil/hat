import {writeFileSync} from 'fs'
import {platform} from 'os'

import {ArrayDesc, PropDescription, TrivialDesc} from './interfaces'

export const getReferencedType = (ref: string): string => {
  // TODO: it should be done better, not by just splitting the string
  return ref.split('/').pop() ?? ''
}

export const getDefaultImports = () => {
  return [
    `import {getApiBase, api} from '../defaults'\n`,
  ]
}

export const getImports = (
  types: Iterable<string>,
  schemasPath: string
): string[] => {
  const imports: string[] = []
  for (const type of types) {
    imports.push(`import {${type}} from '${schemasPath}${type}'`)
  }
  return imports
}

export function tsType(prop: PropDescription): string {
  if ('$ref' in prop) {
    return getReferencedType(prop.$ref)
  }

  if ('anyOf' in prop) {
    return prop.anyOf.map((p) => tsType(p)).join(' | ')
  }

  switch (prop.type) {
    case 'string': {
      if ('format' in prop && prop.format == 'binary') {
        return 'Blob'
      }

      return 'string'
    }
    case 'integer':
      return 'number'
    case 'boolean':
      return 'boolean'
    case 'null':
      return 'null'
    case 'array': {
      if (prop.items) {
        // TODO: call tsType recursively?
        if ('type' in prop.items) {
          switch (prop.items.type) {
            case 'null':
              console.warn('Unsupport null array')
              return 'any[]'
            case 'integer':
              return 'number[]'
            case 'boolean':
              return 'boolean[]'
            case 'string':
              return 'string[]'
            default:
              console.warn('Unknown array type', prop, prop.items)
              return 'any[]'
          }
        } else if ('$ref' in prop.items) {
          const ref = prop.items.$ref
          return `${getReferencedType(ref)}[]`
        } else if ('anyOf' in prop.items) {
          const elems = prop.items.anyOf
          const elemTypes = elems.map((val) => tsType(val)).join(' | ')
          return `(${elemTypes})[]`
        } else {
          console.warn('Unsupported array items:', prop.items)
          return 'any[]'
        }
      } else {
        console.warn('Unsupported array type:', prop.items)
        return 'any[]'
      }
    }
    default:
      console.warn('Unsupported type:', (prop as TrivialDesc | ArrayDesc).type)
      return 'any'
  }
}

function getOperatingSystem() {
  const pltf = platform()
  if (pltf === 'win32') {
    return 'Windows'
  } else if (pltf === 'linux') {
    return 'Linux'
  } else {
    return 'Other'
  }
}

const autogenPrologue =
  '// This file is autogenerated, do not edit directly.\n\n'

export function writeGeneratedContent(file: string, content: string): void {
  const endl = getOperatingSystem() === 'Windows' ? '\r\n' : '\n'
  const newContent = (autogenPrologue + content).replace(/(\r\n|\r|\n)/g, endl)
  writeFileSync(file, newContent)
}
