import commandLineArgs from 'command-line-args'
import {existsSync, mkdirSync, writeFileSync, rmSync} from 'fs'
import {join} from 'path'

type ItemRefDesc = {
  $ref: string
}

type ItemAnyOfDesc = {
  anyOf: [
    {
      type: 'string' | 'integer' // | 'boolean' // check if boolean is possible
    }
  ]
}

type ItemsDescription = ItemRefDesc | ItemAnyOfDesc

type PropTrivialDescription = {
  type: 'string' | 'integer' // | 'boolean' // check if boolean is possible
  title?: string
  format?: string
}

type PropArrayDescription = {
  type: 'array'
  items: ItemsDescription
  title?: string
}

// TODO: check if ItemRefDesc is possible here without an array
type PropDescription = PropTrivialDescription | PropArrayDescription

type HttpMethod = 'get' | 'post' | 'put' | 'delete'

interface ParamDesc {
  name: string
  in: 'query' | 'path' | 'header'
  required: boolean
  schema: PropDescription
}

interface ApiDescription {
  openapi: string
  info: {
    title: string
    version: string
  }
  paths: {
    [path: string]: {
      [method in HttpMethod]: {
        tags: string[]
        summary: string
        operationId: string
        parameters?: ParamDesc[]
        requestBody?: any // TODO: describe
        responses: {
          [status: string]: {
            description: string
            content?: {
              [contentType: string]: {
                schema: ItemRefDesc // TODO: it is likely not always correct
              }
            }
          }
        }
      }
    }
  }
  components: {
    schemas: {
      [name: string]: {
        type: string
        title: string
        required?: string[]
        properties: {
          [name: string]: PropDescription
        }
      }
    }
  }
}

const autogenPrologue =
  '// This file is autogenerated, do not edit directly.\n\n'

function getReferencedType(ref: string): string {
  // TODO: it should be done better, not by just splitting the string
  return ref.split('/').pop()
}

function getUsedTypes(properties: {[name: string]: PropDescription}): string[] {
  const imports = new Set<string>()
  for (const propName in properties) {
    const prop = properties[propName]
    if (prop.type === 'array' && prop.items && '$ref' in prop.items) {
      const type = getReferencedType(prop.items['$ref'])
      imports.add(type)
    }
  }
  return Array.from(imports)
}

function getImports(types: string[], schemasPath: string): string {
  const imports: string[] = []
  for (const type of types) {
    imports.push(`import {${type}} from '${schemasPath}${type}'`)
  }
  return `${imports.join('\n')}` + (imports.length > 0 ? '\n\n' : '')
}

function tsType(prop: PropDescription): string {
  switch (prop.type) {
    case 'string':
      return 'string'
    case 'integer':
      return 'number'
    // TODO: check if it possible to have boolean
    // case 'boolean':
    //   return 'boolean'
    case 'array': {
      if (prop.items) {
        if ('$ref' in prop.items) {
          const ref = prop.items['$ref']
          return `${getReferencedType(ref)}[]`
        } else if ('anyOf' in prop.items) {
          const elems = prop.items['anyOf']
          return `(${elems
            .map((val) => tsType({type: val.type}))
            .join(' | ')})[]`
        } else {
          console.warn('Unsupported array items:', prop.items)
          return 'any[]'
        }
      } else {
        console.warn('Unsupported array type:', prop.items)
        return 'any[]'
      }
    }
    default:
      console.warn('Unsupported type:', (prop as PropDescription).type)
      return 'any'
  }
}

function genSchemas(
  output: string,
  schemas: ApiDescription['components']['schemas']
): void {
  const genProps = (
    props: ApiDescription['components']['schemas'][string]['properties'],
    requiredProps: string[]
  ) => {
    let content = ''
    for (const propName in props) {
      const prop = props[propName]
      const required = requiredProps.find((val) => propName == val) ? '' : '?'
      content += `  ${propName}${required}: ${tsType(prop)}\n`
    }
    return content
  }

  const genSchema = (schema: string) => {
    const types = getUsedTypes(schemas[schema].properties)
    const imports = `${getImports(types, './')}`
    const props = genProps(
      schemas[schema].properties,
      schemas[schema].required || []
    )
    return `${autogenPrologue}${imports}export interface ${schema} {\n${props}}\n`
  }

  if (existsSync(output)) {
    rmSync(output, {recursive: true})
  }
  mkdirSync(output, {recursive: true})

  for (const schema in schemas) {
    const fileContent = `${genSchema(schema)}`
    const fileName = `${output}/${schema}.ts`
    writeFileSync(fileName, fileContent)
  }
}

function genServices(output: string, paths: ApiDescription['paths']): void {
  interface ServiceMethod {
    name: string
    path: string
    parameters: ParamDesc[]
    response: string
    httpMethod: HttpMethod
  }

  const convertServiceName = (name: string) => {
    // remove all spaces and special characters
    const normalized = name.replace(/[^a-zA-Z0-9]/g, '')

    // convert to camel case
    return `${normalized.charAt(0).toLowerCase()}${normalized.slice(1)}`
  }

  const serviceNameFromTag = (tag: string) => {
    const lowered = tag.toLowerCase()
    return `${lowered.charAt(0).toUpperCase()}${lowered.slice(1)}Service`
  }

  const responseType = (
    response: ApiDescription['paths'][string][HttpMethod]['responses'][string]
  ) => {
    if (!response.content) {
      console.warn('Unsupported response content:', response.content)
      return 'any'
    }
    if (!('application/json' in response.content)) {
      console.warn('Unsupported response content:', response.content)
      return 'any'
    }

    const schema = response.content['application/json'].schema
    if ('$ref' in schema) {
      return getReferencedType(schema['$ref'])
    } else {
      console.warn('Unsupported response schema:', schema)
      return 'any'
    }
  }

  const genService = (tag: string, methods: ServiceMethod[]) => {
    let content = ''
    for (const method of methods) {
      const paramSignature = (param: ParamDesc) =>
        `${param.name}${!param.required ? '?' : ''}: ${tsType(param.schema)}`

      const requestParams = method.parameters
        .map((param) => `${paramSignature(param)}`)
        .join(', ')

      // replace all OpenAPI path parameters with JS template literals
      const interpolatedPath = method.path.replace(/\{(.*)?\}/g, '${$1}')

      content += `export const ${method.name} = async (${requestParams}): Promise<${method.response}> => {\n`
      content += `  const api = mande(\`${interpolatedPath}\`)\n`
      content += `  return await api.${method.httpMethod}<${method.response}>('')\n`
      content += `}\n`
    }

    let fileContent = `${autogenPrologue}`
    fileContent += `import {mande} from 'mande'\n\n`
    fileContent += `${content}`
    return fileContent
  }

  if (existsSync(output)) {
    rmSync(output, {recursive: true})
  }
  mkdirSync(output, {recursive: true})

  // group services by tags
  const servicesByTag = new Map<string, ServiceMethod[]>()
  for (const path in paths) {
    const methods = paths[path]
    for (const method in methods) {
      const methodDesc = methods[method as HttpMethod]
      const tags = methodDesc.tags
      for (const tag of tags) {
        if (!servicesByTag.has(tag)) {
          servicesByTag.set(tag, [])
        }
        servicesByTag.get(tag).push({
          name: convertServiceName(methodDesc.summary),
          path: path,
          parameters: methodDesc.parameters ?? [],
          response: responseType(methodDesc.responses['200']), // TODO: it is better to search for suitable response, not for a default
          httpMethod: method as HttpMethod,
        })
      }
    }
  }

  // generator actual code for every service
  for (const [tag, methods] of servicesByTag) {
    const fileContent = genService(tag, methods)
    const fileName = `${output}/${serviceNameFromTag(tag)}.ts`
    writeFileSync(fileName, fileContent)
  }
}

function main() {
  const options = commandLineArgs([
    {name: 'input', alias: 'i', type: String},
    {name: 'output', alias: 'o', type: String},
  ])

  fetch(options.input)
    .then((response) => {
      response.json().then((data: ApiDescription) => {
        if (existsSync(options.output)) {
          rmSync(options.output, {recursive: true})
        }
        mkdirSync(options.output, {recursive: true})

        genSchemas(join(options.output, 'schemas'), data.components.schemas)
        genServices(join(options.output, 'services'), data.paths)
      })
    })
    .catch((error) => {
      console.error('Failure:', error)
    })
}

main()
